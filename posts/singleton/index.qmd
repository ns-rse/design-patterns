---
title: "Singleton"
author: "Neil Shephard"
date: "2023-03-28"
categories: [python, singleton]
image: https://live.staticflickr.com/4126/4949025595_b772c9e608_k.jpg
from: markdown+emoji
toc: true
toc-depth: 3
toc-location: right
execute:
  code_fold: true
  code_link: true
  code_tools: true
  fig-cap-location: top
  tbl-cap-location: top
  warning: false
---

The singleton pattern ensures there is only one instance of a class and at the same time it provides a global access
point to that instance.

![[_Another type of Singelton._ Picture by me.](https://www.flickr.com/photos/slackline/4949025595/)](https://live.staticflickr.com/4126/4949025595_b772c9e608_k.jpg)

**Singletons violate the _Single Responsibility Principle_** and their use is considered poor
practice. Further having global variables/objects that can be accessed from anywhere isn't particularly safe as content
can be over-written at any point leading to problems. Regardless I'm on a mission to learn!

Why would you use a Singleton pattern if it violates the _Single Responsibility Principle_ and is potentially unsafe?
Well it is commonly used when a centralised point of access is require to say a database or a configuration manager.

# Implementation

Implementing singletons in Python is pretty straight-forward courtesy of the `__new__` method. However, because of the
hazard of only having a single instance of the class you need to be mindful when using threads (multiple processes) so
that there is no conflict. This is achieved using the `Lock` and `Thread` classes from the
[`threading`](https://docs.python.org/3/library/threading.html) library.

``` {.python}
from threading import Lock, Thread

class Singleton:
    _instance = {}

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance

def main():
    s1 = Singleton()
    s2 = Singleton()

    print(s1 is s2)  # True

```


# Practical Example

Beyond demonstrating that a second instance of the `Singleton` class isn't instantiated to the `s2` object that is a
fairly useless example. A more practical example might be when you wish to have a connection to a database but only
wish to have a single connection and not to create lots of new connections every time you wish to interact with the
database.

``` {.python}
from threading import Lock, Thread

import sqlite3

class dbConnectSQLite3:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls, *args, **kwargs)
            cls._instance.connection = sqlite3.connect()
        return cls._instance

    def __init__(self, db_path: Path):
        """Initialise the class.

        Parameters
        ----------
        db_path: Path
            Path to an sqlite3 database.
        """
        self.connection = sqlite3.connect(db_path)
        self.cursor = self.connection.cursor()

    def db_query(self, db_query: str) -> Any:
        """Query the database.

        Parameters
        ----------
        db_query: str
            A valid SQL query.
        """
        self.cursor.execute(db_query)
        return self.cursor.fetchall()

    def add_data(self, table: str, data: str):
        """Add data to the database."""

    def create_table(self, fields: list):
        """Create a table in the database."""

```

# Links

* [Singleton - Refactoring Guru](https://refactoring.guru/design-patterns/singleton)
* [Singleton pattern in Python: A Beginnerâ€™s Guide | by Arun Suresh Kumar | Medium](https://medium.com/@yeaske/singleton-pattern-in-python-a-beginners-guide-75e97ce75554)
* [SQLite and SQLAlchemy - Real Python](https://realpython.com/lessons/sqlite-sqlalchemy-python-overview/)
